# -*- coding: utf-8 -*-
"""
R Source for Neovim Completion Manager, to be used with nvim-R

by Gabriel Alcaras
"""

import re
import neovim
from os import listdir

from cm import register_source, getLogger, Base  # pylint: disable=E0401

LOGGER = getLogger(__name__)
R_WORD = re.compile(r'[\w\$_\.]+$')

register_source(name='R',
                priority=9,
                abbreviation='R',
                word_pattern=r'[\w_\.]+',
                scoping=True,
                scopes=['r'],
                early_cache=1,
                cm_refresh_patterns=[r'\$'],)


def to_matches(lines):
    """Transform omni lists from Nvim-R into list of NCM matches

    :lines: list of lines from an omni list
    :returns: list of ncm matches
    """

    cm_list = list()

    for line in lines:
        parts = re.split('\x06', line)
        cm_list.append(dict(word=parts[0],
                            menu=parts[1] + ' [' + parts[3] + ']',
                            struct=parts[2],
                            pkg=parts[3]))

    return cm_list


def filter_matches_struct(ncm_matches, struct=""):
    """Filter list of ncm matches based on their types (str() in R)

    :ncm_matches: list of matches (dictionaries)
    :struct: only show matches of given type
    :returns: filtered list of ncm matches
    """

    if not struct:
        return ncm_matches

    ncm_matches = [d for d in ncm_matches if d['struct'] == struct]

    return ncm_matches


def filter_matches_pkgs(ncm_matches, pkg=None):
    """Filter list of ncm matches with R packages

    :ncm_matches: list of matches (dictionaries)
    :pkg: only show matches from given R packages
    :returns: filtered list of ncm matches
    """

    if not pkg:
        return ncm_matches

    ncm_matches = [d for d in ncm_matches if any(p in d['pkg'] for p in pkg)]

    return ncm_matches


def filter_matches(ncm_matches, typed="", hide="", rm_typed=False):
    """Filter list of ncm matches

    :ncm_matches: list of matches (dictionaries)
    :typed: filter matches with this string
    :hide: filter out matches containing this string
    :rm_typed: remove typed string from the filtered matches
    :returns: filtered list of cm dictionaries
    """

    filtered_list = list()

    for match in ncm_matches:
        if typed and typed in match['word']:
            if hide and hide in match['word']:
                continue

            if rm_typed:
                match['word'] = match['word'].replace(typed, '')

            filtered_list.append(match)

    return filtered_list


class Source(Base):
    """Completion Manager Source for R language"""

    def __init__(self, nvim):
        super(Source, self).__init__(nvim)

        self._nvimr = self.nvim.eval('$NVIMR_ID')
        self._tmpdir = self.nvim.eval('g:rplugin_tmpdir')

        self._pkg_loaded = list()
        self._pkg_matches = list()
        self._fnc_matches = list()
        self._obj_matches = list()

        self.get_all_pkg_matches()
        self._start_nvimr()

    def _start_nvimr(self):
        """Start nvim-R"""

        try:
            if self.nvim.eval('g:SendCmdToR') == "function('SendCmdToR_fake')":
                self.nvim.funcs.StartR('R')
        except neovim.api.nvim.NvimError as ex:
            self.message('error', 'Could not start nvim-R :(')
            LOGGER.exception(ex)

    def update_loaded_pkgs(self):
        """Update list of loaded R packages

        :returns: 1 if loaded packages have changed, 0 otherwise
        """

        loadpkg = self._tmpdir + '/loaded_pkgs_' + self._nvimr
        self.nvim.funcs.AddForDeletion(loadpkg)

        # Send an R command via nvim-R's Nvimcom to write file with currently
        # loaded packages
        rcmd = 'writeLines(text = paste(.packages(), collapse="\\n"), '
        rcmd += 'con = "' + loadpkg + '")'
        self.nvim.funcs.SendToNvimcom('\x08' + self._nvimr + rcmd)

        old_pkgs = self._pkg_loaded

        try:
            loaded_pkgs = open(loadpkg, 'r')
            pkgs = [pkg.strip() for pkg in loaded_pkgs.readlines()]
            self._pkg_loaded = pkgs

            loaded_pkgs.close()
        except FileNotFoundError:
            LOGGER.warn('Cannot find loaded R packages. Please start nvim-R')

        if set(old_pkgs) == set(self._pkg_loaded):
            return 0

        return 1

    def get_all_obj_matches(self):
        """Populate candidates with all R objects in the environment"""

        self.nvim.funcs.BuildROmniList("")
        globenv_file = self._tmpdir + '/GlobalEnvList_' + self._nvimr

        with open(globenv_file, 'r') as globenv:
            objs = [obj.strip() for obj in globenv.readlines()]

        self._obj_matches = to_matches(objs)

    def get_compfiles(self):
        """Get all omnilists files generated by Nvim-R

        :returns: list of omnilists filepaths
        """

        compdir = self.nvim.eval('g:rplugin_compldir')
        comps = [f for f in listdir(compdir) if 'omnils' in f]

        return [compdir + '/' + comp for comp in comps]

    def get_all_pkg_matches(self):
        """Populate matches list with candidates from every R package"""

        compfiles = self.get_compfiles()

        for pkg in compfiles:
            with open(pkg, 'r') as omnil:
                comps = [pkg.strip() for pkg in omnil.readlines()]

            self._pkg_matches.extend(to_matches(comps))

    def cm_refresh(self, info, ctx):
        """Refresh NCM list of matches"""

        match = re.search(R_WORD, ctx['typed'])

        if match:
            pattern = match[0]
            LOGGER.info('pattern: %s', pattern)
        else:
            return

        self.get_all_obj_matches()
        matches = self._obj_matches

        if self.update_loaded_pkgs():
            LOGGER.info('Update Loaded R packages: %s', self._pkg_loaded)
            funcs = filter_matches_pkgs(self._pkg_matches, self._pkg_loaded)
            funcs = filter_matches_struct(funcs, 'function')
            self._fnc_matches = funcs

        matches.extend(self._fnc_matches)

        if '$' in pattern:
            matches = filter_matches(matches, pattern, rm_typed=True)
        else:
            matches = filter_matches(matches, pattern, hide='$')

        LOGGER.debug("matches: [%s]", matches)
        self.complete(info, ctx, ctx['startcol'], matches)
